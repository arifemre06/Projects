import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * This class accomplishes Mission Nuke'm
 */
public class DefenseAgainstEnemyTroops {
    private ArrayList<Integer> numberOfEnemiesArrivingPerHour;

    public DefenseAgainstEnemyTroops(ArrayList<Integer> numberOfEnemiesArrivingPerHour){
        this.numberOfEnemiesArrivingPerHour = numberOfEnemiesArrivingPerHour;
    }

    public ArrayList<Integer> getNumberOfEnemiesArrivingPerHour() {
        return numberOfEnemiesArrivingPerHour;
    }

    private int getRechargedWeaponPower(int hoursCharging){
        return hoursCharging*hoursCharging;
    }

    /**
     *     Function to implement the given dynamic programming algorithm
     *     SOL(0) <- 0
     *     HOURS(0) <- [ ]
     *     For{j <- 1...N}
     *         SOL(j) <- max_{0<=i<j} [ (SOL(i) + min[ E(j), P(j âˆ’ i) ] ]
     *         HOURS(j) <- [HOURS(i), j]
     *     EndFor
     *
     * @return OptimalEnemyDefenseSolution
     */
    public OptimalEnemyDefenseSolution getOptimalDefenseSolutionDP(){
        // TODO: YOUR CODE HERE
        int[] sol = new int[numberOfEnemiesArrivingPerHour.size()+1];
        sol[0] = 0;
        Map<Integer,Integer> hourchain = new HashMap<>();
        hourchain.put(0,0);
        ArrayList<Integer> hours = new ArrayList<>();
        for (int j = 0; j < numberOfEnemiesArrivingPerHour.size(); j++) {
            int max = 0;
            int maxindex = 0;
            for(int i = 0;i <= j;i++){
                int temp = sol[i] + Math.min(numberOfEnemiesArrivingPerHour.get(j), getRechargedWeaponPower(j - i + 1));
                if(temp>max){
                    max = temp;
                    maxindex = i;
                }

            }
                sol[j+1] = sol[maxindex] + Math.min(numberOfEnemiesArrivingPerHour.get(j), getRechargedWeaponPower(j - maxindex + 1));

                hourchain.put(j+1,maxindex);

            if(j == numberOfEnemiesArrivingPerHour.size() - 1){
                sol[j+1] = sol[maxindex] + Math.min(numberOfEnemiesArrivingPerHour.get(j), getRechargedWeaponPower(j+1 - maxindex));

                int a = hourchain.get(j+1);
                hours.add(j+1);
                while(a != 0){
                    hours.add(a);
                    a = hourchain.get(a);

                }

                Collections.sort(hours);
                return new OptimalEnemyDefenseSolution(sol[j+1],hours);
            }


    }
        return null;
}
}
